## 一、双指针

思路与算法

我们直接按照题目的要求模拟即可。我们使用两个指针 i 和 j，初始时分别指向两个字符串的首个位置。随后的每次循环中，依次进行如下的两步操作：

如果 i 没有超出 word<sub>1</sub> 的范围，就将 word<sub>1</sub> [i] 加入答案，并且将 i 移动一个位置；

如果 j 没有超出 word<sub>1</sub> 的范围，就将 word<sub>2</sub> [j] 加入答案，并且将 j 移动一个位置。

当 i 和 j 都超出对应的范围后，结束循环并返回答案即可。

代码
``` python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        result=[]
        i, n, m=0, len(word1), len(word2)

        while i< n or i<m:
            if i<n:
                result.append(word1[i])
            if i<m:
                result.append(word2[i])
            i+=1
        
        return "".join(result)    
```

时间复杂度：O(N+M)，其中 N 和 M 分别为 word<sub>1</sub> 和 word<sub>2</sub>的长度。两个字符串中的每个字符都会被放入答案中一次。


空间复杂度：O(N+M)，即为答案占用的空间大小。

## 二、
这是LeetCode上"交替合并字符串"问题的第二种解法。这段代码实现了将两个字符串交替合并的功能。

代码分析：

n = min(len(word1), len(word2)) - 计算两个字符串中较短的那个的长度。这是因为我们只能交替合并到较短字符串的末尾。

s = '' - 初始化一个空字符串用于存储结果。

for i in range(n): - 遍历从0到n-1的索引。

在循环中:

s += word1[i] - 添加第一个字符串的当前字符
s += word2[i] - 添加第二个字符串的当前字符
return s + word1[n:] + word2[n:] - 返回合并后的结果，包括:

已经交替合并的部分(s)
第一个字符串可能剩余的部分(word1[n:])
第二个字符串可能剩余的部分(word2[n:])
这种方法的优点是简洁明了，先处理两个字符串共同长度的部分，然后直接附加剩余部分，不需要像第一种解法那样使用指针和条件判断。

时间复杂度为O(N)，空间复杂度为O(N)，其中N是两个字符串的总长度。

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        n = min(len(word1), len(word2))
        s = ''
        for i in range(n):
            s += word1[i]
            s += word2[i]
        return s + word1[n:] + word2[n:]
```
